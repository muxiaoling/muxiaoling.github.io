<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>缓存常见问题</title>
    <url>/2021/02/21/%E7%BC%93%E5%AD%98%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><p>缓存击穿某个热点key过期，导致大量请求打到数据库上，导致数据库压力激增的一种现象。</p>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>分布式锁：对访问数据库的大量key加分布式锁，同一时刻，只允许一个请求访问，访问过后将结果缓存到redis中，这样后来的请求便可以直接获取redis中的结果。</p>
<span id="more"></span>

<h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><p>缓存雪崩是短时间内，缓存中的key大面积过期，导致所有请求打到数据库中。</p>
<h3 id="解决方法-1"><a href="#解决方法-1" class="headerlink" title="解决方法"></a>解决方法</h3><p>可以给不同key的过期时间加上随机值，防止某个时间大量的key同时过期。对应热key，可以设置成永不过期的方式。</p>
<h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><p>缓存穿透是大量请求中的key在缓存中不存在，数据库中也不存在，导致数据库压力过大的一种现象。</p>
<h3 id="解决方法-2"><a href="#解决方法-2" class="headerlink" title="解决方法"></a>解决方法</h3><p><strong>缓存空对象</strong></p>
<p>redis是key-value存储的键值对数据库，可以将不存在的key缓存起来，下次该key访问时便不会走数据库。但是如果大量key都是不同的，那就会造成redis中缓存大量无效的key，浪费内存。</p>
<p><strong>布隆过滤器</strong></p>
<p>采用位数组的方式，不直接存储元素，而是存储元素是否存在的状态 。</p>
<p>具体思想：</p>
<ul>
<li>一个初始状态都为0的位数组</li>
<li>元素经过N个散列函数计算出元素在数组当中的位置，并且将数组中对应位置的0改成1 </li>
<li>如果此时需要判断元素X是否存在，那么元素X也会经过这N个散列函数的运算而得到数组中的若干个位置，如果得到的若干个位置中的值均为1，那么则证明元素X很可能存在与集合当中，反之则证明元素X一定不存在于集合当中。</li>
</ul>
<p>优缺点：</p>
<p>优点：在空间和时间方面，都有着巨大的优势。因为不是存完整的数据，是一个二进制向量，能节省大量的内存空间，时间复杂度方面，由于计算时是根据散列函数计算查询的，那么假设有N个散列函数，那么时间复杂度就是O(N)；同时在存储元素时存储的不是元素本身，而是二进制向量，所以在一些对保密性要求严格的场景有一定优势。</p>
<p>缺点：存在一定的误判（存进布隆过滤器里的元素越多，误判率越高）；不能删除布隆过滤器里的元素 。</p>
]]></content>
      <categories>
        <category>缓存</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
</search>
