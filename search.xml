<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>MySQL中的count(*),count(1),count(字段)有什么区别？</title>
    <url>/p/5fed1c16/</url>
    <content><![CDATA[<h2 id="count-是什么？"><a href="#count-是什么？" class="headerlink" title="count()是什么？"></a>count()是什么？</h2><p>当我们对一张数据表的记录数量进行统计时，会使用到count()函数。count() 是一个聚合函数，函数的参数不仅可以是字段名，也可以是其他任意表达式，该函数作用是<strong>统计符合查询条件的记录中，函数指定的参数不为 NULL 的记录有多少个</strong>。</p>
<p>count函数的使用方式有多种：count(*)、count(1)、count(字段) 等。<span id="more"></span></p>
<h2 id="哪种count-性能最好？"><a href="#哪种count-性能最好？" class="headerlink" title="哪种count()性能最好？"></a>哪种count()性能最好？</h2><h3 id="简单了解一下count函数"><a href="#简单了解一下count函数" class="headerlink" title="简单了解一下count函数"></a>简单了解一下count函数</h3><p>要理解这个问题，需要弄清楚count的原理。说明：我所使用的MySQL存储引擎是基于InnoDB的。</p>
<p>如果count()函数的参数是一个普通字段名：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(name) <span class="keyword">from</span> <span class="keyword">user</span>;</span><br></pre></td></tr></table></figure>

<p>这条语句是统计user表中，name字段不为null的记录有多少条。也就是说name字段如果为null，将不会被统计进去。</p>
<p>如果count()函数的参数是数字1，是什么意思？</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="number">1</span>) <span class="keyword">from</span> <span class="keyword">user</span>;</span><br></pre></td></tr></table></figure>

<p>这条语句的意思是统计user表中，1这个表达式不为null的记录 有多少条。这个1就是就相当于一个表达式，他永远不为null，所以这条语句就是统计user表有多少条记录。</p>
<p>如果将count()参数换成<code>*</code>是什么意思？</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> <span class="keyword">user</span>;</span><br></pre></td></tr></table></figure>

<p>看到<code>*</code>这个字符的时候你可能会和<code>select *</code>这条语句相对应，<strong>其实并不是这样的</strong>。</p>
<p>count(*)其实是相当于count(0)的意思，当MySQL解析count(*)时，会将*参数转化为参数 0 来处理。</p>
<p>而0和1一样，同样作为永不为null的表达式来说，在意思上就可以理解为获取表中所有记录的条数。count(*)在性能上跟count(1)没有差异性。</p>
<p>引用MySQL 5.7官方手册的一句话：</p>
<blockquote>
<p><em>InnoDB handles SELECT COUNT(*) and SELECT COUNT(1) operations in the same way. There is no performance difference.</em></p>
<p>译：<em>InnoDB以相同的方式处理SELECT COUNT（*）和SELECT COUNT（1）操作，没有性能上的差异</em></p>
</blockquote>
<p>并且MySQL对count(*)和count(1)还进行了优化，当存在多个二级索引时，优化器会使用key_len 最小的二级索引进行扫描。（注意：只有当没有二级索引的时候，才会采用主键索引来进行统计。）</p>
<p>如果有二级索引那么会采用二级索引来进行统计，因为Inode存储引擎中索引文件采用B+树的形式进行存储，Innodb引擎中聚簇索引存储的是一条完整的数据字段，二级索引存储的是部分字段，当需要进行count(*)统计时，要将磁盘中的数据，以页为单位（一页&#x3D;16kb）加载到内存中，采用二级索引可以一次加载更多的数据，减少IO次数。</p>
<h3 id="count-1-执行过程"><a href="#count-1-执行过程" class="headerlink" title="count(1) 执行过程"></a>count(1) 执行过程</h3><p>以下面这条语句作为例子：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="number">1</span>) <span class="keyword">from</span> <span class="keyword">user</span>;</span><br></pre></td></tr></table></figure>

<p>针对上面这条语句，这张图表中不存在二级索引时的执行计划：</p>
<p><img src="https://s2.loli.net/2022/11/01/HhelurAwSoJB9aW.png" alt="image-20221101165033747"></p>
<p>这张图是创建了二级索引时的执行计划：</p>
<p><img src="https://s2.loli.net/2022/11/01/JAVDNGwZkqjtvWI.png" alt="image-20221101164946055"></p>
<p>InnoDB 循环遍历聚簇索引（主键索引），将读取到的记录返回给 server 层，<strong>但是不会读取记录中的任何字段的值</strong>，因为 count 函数的参数是 1，不是字段，所以不需要读取记录中的字段值。参数 1 很明显并不是 NULL，因此 server 层每从 InnoDB 读取到一条记录，就将 count 变量加 1。</p>
<p>可以看到，count(1) 相比 count(主键字段) 少一个步骤，就是不需要读取记录中的字段值，所以通常会说 count(1) 执行效率会比 count(主键字段) 高一点。</p>
<p>但是，如果表里有二级索引时，InnoDB 循环遍历的对象就二级索引了。</p>
<h3 id="count-执行过程"><a href="#count-执行过程" class="headerlink" title="count(*)执行过程"></a>count(*)执行过程</h3><p><strong>count(*) 其实等于 count(<code>0</code>)<strong>，也就是说，当你使用 count(*) 时，MySQL 会将 <code>*</code> 参数转化为参数 0 来处理。所以，</strong>count(*) 执行过程跟 count(1) 执行过程基本一样的</strong>，性能没有什么差异。</p>
<p>当没有二级索引的时候，同样也是采用主键索引来进行统计。</p>
<h3 id="count-字段-执行过程"><a href="#count-字段-执行过程" class="headerlink" title="count(字段)执行过程"></a>count(字段)执行过程</h3><p>以下面这条语句为例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span> name不是索引，普通字段</span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(name) <span class="keyword">from</span> <span class="keyword">user</span>;</span><br></pre></td></tr></table></figure>

<p>对于这个不存在二级索引时的查询，会采用全表扫描的方式来计数，所以他的执行效率是比较差的。</p>
<p><img src="https://s2.loli.net/2022/11/01/Mbes694BWqIQXFn.png" alt="image-20221101170515004"></p>
<h3 id="综上所述"><a href="#综上所述" class="headerlink" title="综上所述"></a>综上所述</h3><p>count(1)、 count(*)、 count(主键字段)在执行的时候，如果表里存在二级索引，优化器就会选择二级索引进行扫描。所以，如果要执行 count(1)、 count(*)、 count(主键字段) 时，尽量在数据表上建立二级索引，这样优化器会自动采用 key_len 最小的二级索引进行扫描，相比于扫描主键索引效率会高一些。尽量避免使用 count(字段) 来统计记录个数，因为它的效率是最差的，会采用全表扫描的方式来统计。</p>
<h2 id="为什么要采用遍历的方式来计数？"><a href="#为什么要采用遍历的方式来计数？" class="headerlink" title="为什么要采用遍历的方式来计数？"></a>为什么要采用遍历的方式来计数？</h2><p>前面的案例都是基于 Innodb 存储引擎来说明的，但是在 MyISAM 存储引擎里，执行 count 函数的方式是不一样的，通常在没有任何查询条件下的 count(*)，MyISAM 的查询速度要明显快于 InnoDB。</p>
<p>使用 MyISAM 引擎时，执行 count 函数只需要 O(1 )复杂度，这是因为每张 MyISAM 的数据表都有一个 meta 信息有存储了row_count值，由表级锁保证一致性，所以直接读取 row_count 值就是 count 函数的执行结果。</p>
<p><strong>而 InnoDB 存储引擎是支持事务的，同一个时刻的多个查询，由于多版本并发控制（MVCC）的原因，InnoDB 表“应该返回多少行”也是不确定的，所以无法像 MyISAM一样，只维护一个 row_count 变量。</strong></p>
<h2 id="如何弥补count-的不足"><a href="#如何弥补count-的不足" class="headerlink" title="如何弥补count(*)的不足"></a>如何弥补count(*)的不足</h2><p>如果对于一张数据量大的表来说，其实是很不好的。因为数据库会逐条统计得到答案。</p>
<p>所以面对大表的记录统计，我们可以采用两种方式来统计：①估计法 ②额外表保存计数值</p>
<h3 id="估计法"><a href="#估计法" class="headerlink" title="估计法"></a>估计法</h3><p>业务对于统计个数不需要很精确，可以使用 <code>show table status</code> 或者 <code>explain</code> 命令来表进行估算。</p>
<p>执行 explain 命令效率是很高的，因为它并不会真正的去查询。</p>
<blockquote>
<p>mysql-5.5之前：</p>
<p>首先找到查询第一个记录所在的page（记为PLeft），统计PLeft里的记录数（记为Records_PLeft），之后找到最后一个记录所在的page（记为PRight），统计PRight的记录数（Records_PRight），之后将Records_PLeft与Records_PRight取平均，最后乘以总共的page数目（记为Page_Num）。公式如下：</p>
<figure class="highlight mathematica"><table><tr><td class="code"><pre><span class="line"><span class="variable">Rows</span> <span class="operator">=</span> <span class="punctuation">(</span><span class="punctuation">(</span><span class="type">Records_PLeft</span> <span class="operator">+</span> <span class="type">Records_PRight</span><span class="punctuation">)</span><span class="operator">/</span><span class="number">2</span><span class="punctuation">)</span><span class="operator">*</span><span class="type">Page_Num</span></span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>mysql-5.5之后：</p>
<p>上述预估偏差大的关键在于有偏，而有偏的关键在于采样的page数太少了，事实上只采样了边界2个，新算法的思路很简单，增加采样数目，比如采样10个page，这样可以在一定程度上降低偏差。</p>
<p>具体来说，mysql除了边界2个外，还沿着左侧page往右连续查找8个page，如果总的page数目小于等于10个，那么预估的Rows和真实的Rows一致。虽然该方式在一定程度上缓解了有偏的问题，但是不准确还是存在的。公式如下：</p>
<figure class="highlight mathematica"><table><tr><td class="code"><pre><span class="line"><span class="variable">Rows</span> <span class="operator">=</span> <span class="punctuation">(</span><span class="punctuation">(</span><span class="type">Records_PLeft</span> <span class="operator">+</span>  <span class="type">Records_P1</span> <span class="operator">+</span> <span class="type">Records_P2</span> <span class="operator">+</span> <span class="operator">...</span> <span class="operator">+</span> <span class="type">Records_P8</span> <span class="operator">+</span> <span class="type">Records_PRight</span><span class="punctuation">)</span><span class="operator">/</span><span class="number">10</span><span class="punctuation">)</span><span class="operator">*</span><span class="type">Page_Num</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="额外表保存计数值"><a href="#额外表保存计数值" class="headerlink" title="额外表保存计数值"></a>额外表保存计数值</h3><p>对于记录数较多的表，如果是想精确的获取表的记录总数，我们可以将这个计数值保存到单独的一张计数表中。</p>
<p>当我们在数据表插入一条记录的同时，将计数表中的计数字段 + 1，在新增和删除操作时，我们需要额外维护这个计数表。</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>缓存常见问题</title>
    <url>/p/5e0bc5d1/</url>
    <content><![CDATA[<h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><p>缓存击穿某个热点key过期，导致大量请求打到数据库上，导致数据库压力激增的一种现象。</p>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>分布式锁：对访问数据库的大量key加分布式锁，同一时刻，只允许一个请求访问，访问过后将结果缓存到redis中，这样后来的请求便可以直接获取redis中的结果。</p>
<span id="more"></span>

<h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><p>缓存雪崩是短时间内，缓存中的key大面积过期，导致所有请求打到数据库中。</p>
<h3 id="解决方法-1"><a href="#解决方法-1" class="headerlink" title="解决方法"></a>解决方法</h3><p>可以给不同key的过期时间加上随机值，防止某个时间大量的key同时过期。对应热key，可以设置成永不过期的方式。</p>
<h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><p>缓存穿透是大量请求中的key在缓存中不存在，数据库中也不存在，导致数据库压力过大的一种现象。</p>
<h3 id="解决方法-2"><a href="#解决方法-2" class="headerlink" title="解决方法"></a>解决方法</h3><p><strong>缓存空对象</strong></p>
<p>redis是key-value存储的键值对数据库，可以将不存在的key缓存起来，下次访问该key时便不会走数据库。但是如果大量key都是不同的，那就会造成redis中缓存大量无效的key，浪费内存。</p>
<p><strong>布隆过滤器</strong></p>
<p>采用位数组的方式，不直接存储元素，而是存储元素是否存在的状态 。</p>
<p>具体思想：</p>
<ul>
<li><p>一个初始状态都为0的位数组</p>
<p><img src="https://s2.loli.net/2022/10/27/ehrDagX5YdnLHG6.png" alt="位数组"></p>
</li>
<li><p>元素经过N个散列函数计算出元素在数组当中的位置，并且将数组中对应位置的0改成1 </p>
<p><img src="https://s2.loli.net/2022/10/27/qWPKFhHbYlO51jX.png" alt="散列"></p>
</li>
<li><p>如果此时需要判断元素X是否存在，那么元素X也会经过这N个散列函数的运算而得到数组中的若干个位置，如果得到的若干个位置中的值均为1，那么则证明元素X很可能存在与集合当中，反之则证明元素X一定不存在于集合当中。 </p>
<p><img src="https://s2.loli.net/2022/10/27/KOSL2IePpTxFYwi.png" alt="不存在"></p>
</li>
</ul>
<p>优缺点：</p>
<p>优点：在空间和时间方面，都有着巨大的优势。因为布隆过滤器不是存完整的数据，而存是一个二进制向量，能节省大量的内存空间。在时间复杂度方面，由于计算时是根据散列函数计算查询的，那么假设有N个散列函数，那么时间复杂度就是O(N)；</p>
<p>缺点：存在一定的误判（存进布隆过滤器里的元素越多，误判率越高）；不能删除布隆过滤器里的元素 。</p>
<p><strong>布隆过滤器应用</strong></p>
<ul>
<li><p>Redission实现布隆过滤器</p>
<ol>
<li><p>引入依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--redisson--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.redisson<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>redisson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.13.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>编写配置类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedissonConfig</span> &#123;</span><br><span class="line">    <span class="comment">//redis的ip地址</span></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;spring.redis.host&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String redisHost;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//redis端口号</span></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;spring.redis.port&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String redisPort;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//redis密码</span></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;spring.redis.password&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String redisPassword;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedissonClient <span class="title function_">redissonClient</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Config</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Config</span>();</span><br><span class="line">        config.useSingleServer().setAddress(<span class="string">&quot;redis://&quot;</span>+ redisHost + <span class="string">&quot;:&quot;</span> + redisPort)</span><br><span class="line">        .setPassword(redisPassword);</span><br><span class="line">        <span class="comment">// 创建RedissonClient对象</span></span><br><span class="line">        <span class="keyword">return</span> Redisson.create(config);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>应用</p>
<p>利用单例模式将RBloomFilter封装成一个工具类，以便项目使用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BloomFilterUtil</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Redisson redisson;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BloomFilterUtil</span><span class="params">(Redisson redisson)</span>&#123;</span><br><span class="line">        BloomFilterUtil.redisson = redisson;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">BloomFilterUtil</span> <span class="params">()</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> RBloomFilter&lt;Long&gt; bloomFilter;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> RBloomFilter&lt;Long&gt; <span class="title function_">getBloomFilter</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (bloomFilter == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (BloomFilterUtil.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (bloomFilter == <span class="literal">null</span>) &#123;</span><br><span class="line">                    bloomFilter = redisson.getBloomFilter(name);</span><br><span class="line">                    bloomFilter.tryInit(<span class="number">100000000</span>,<span class="number">0.04</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bloomFilter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">addElement</span><span class="params">(Long element, String name)</span> &#123;</span><br><span class="line">        getBloomFilter(name).add(element);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Long element, String name)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getBloomFilter(name).contains(element);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
]]></content>
      <categories>
        <category>缓存</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
</search>
